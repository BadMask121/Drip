module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAuthPaylod {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateVendor {
  count: Int!
}

type AuthPaylod {
  id: ID!
  token: String
  vendor: Vendor!
}

type AuthPaylodConnection {
  pageInfo: PageInfo!
  edges: [AuthPaylodEdge]!
  aggregate: AggregateAuthPaylod!
}

input AuthPaylodCreateInput {
  id: ID
  token: String
  vendor: VendorCreateOneInput!
}

type AuthPaylodEdge {
  node: AuthPaylod!
  cursor: String!
}

enum AuthPaylodOrderByInput {
  id_ASC
  id_DESC
  token_ASC
  token_DESC
}

type AuthPaylodPreviousValues {
  id: ID!
  token: String
}

type AuthPaylodSubscriptionPayload {
  mutation: MutationType!
  node: AuthPaylod
  updatedFields: [String!]
  previousValues: AuthPaylodPreviousValues
}

input AuthPaylodSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AuthPaylodWhereInput
  AND: [AuthPaylodSubscriptionWhereInput!]
  OR: [AuthPaylodSubscriptionWhereInput!]
  NOT: [AuthPaylodSubscriptionWhereInput!]
}

input AuthPaylodUpdateInput {
  token: String
  vendor: VendorUpdateOneRequiredInput
}

input AuthPaylodUpdateManyMutationInput {
  token: String
}

input AuthPaylodWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  vendor: VendorWhereInput
  AND: [AuthPaylodWhereInput!]
  OR: [AuthPaylodWhereInput!]
  NOT: [AuthPaylodWhereInput!]
}

input AuthPaylodWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createAuthPaylod(data: AuthPaylodCreateInput!): AuthPaylod!
  updateAuthPaylod(data: AuthPaylodUpdateInput!, where: AuthPaylodWhereUniqueInput!): AuthPaylod
  updateManyAuthPaylods(data: AuthPaylodUpdateManyMutationInput!, where: AuthPaylodWhereInput): BatchPayload!
  upsertAuthPaylod(where: AuthPaylodWhereUniqueInput!, create: AuthPaylodCreateInput!, update: AuthPaylodUpdateInput!): AuthPaylod!
  deleteAuthPaylod(where: AuthPaylodWhereUniqueInput!): AuthPaylod
  deleteManyAuthPaylods(where: AuthPaylodWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createVendor(data: VendorCreateInput!): Vendor!
  updateVendor(data: VendorUpdateInput!, where: VendorWhereUniqueInput!): Vendor
  updateManyVendors(data: VendorUpdateManyMutationInput!, where: VendorWhereInput): BatchPayload!
  upsertVendor(where: VendorWhereUniqueInput!, create: VendorCreateInput!, update: VendorUpdateInput!): Vendor!
  deleteVendor(where: VendorWhereUniqueInput!): Vendor
  deleteManyVendors(where: VendorWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  vendor: Vendor
  product: Product
  date: String!
  status: String!
  quantity: Int!
  createdAt: DateTime
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  vendor: VendorCreateOneInput
  product: ProductCreateOneInput
  date: String!
  status: String!
  quantity: Int!
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  status_ASC
  status_DESC
  quantity_ASC
  quantity_DESC
  createdAt_ASC
  createdAt_DESC
}

type OrderPreviousValues {
  id: ID!
  date: String!
  status: String!
  quantity: Int!
  createdAt: DateTime
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  vendor: VendorUpdateOneInput
  product: ProductUpdateOneInput
  date: String
  status: String
  quantity: Int
}

input OrderUpdateManyMutationInput {
  date: String
  status: String
  quantity: Int
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  vendor: VendorWhereInput
  product: ProductWhereInput
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: ID!
  name: String!
  price: Float!
  brand: String!
  size: Int!
  size_type: String!
  category: String!
  createdAt: DateTime
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  name: String!
  price: Float!
  brand: String!
  size: Int!
  size_type: String!
  category: String!
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  brand_ASC
  brand_DESC
  size_ASC
  size_DESC
  size_type_ASC
  size_type_DESC
  category_ASC
  category_DESC
  createdAt_ASC
  createdAt_DESC
}

type ProductPreviousValues {
  id: ID!
  name: String!
  price: Float!
  brand: String!
  size: Int!
  size_type: String!
  category: String!
  createdAt: DateTime
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  name: String
  price: Float
  brand: String
  size: Int
  size_type: String
  category: String
}

input ProductUpdateInput {
  name: String
  price: Float
  brand: String
  size: Int
  size_type: String
  category: String
}

input ProductUpdateManyMutationInput {
  name: String
  price: Float
  brand: String
  size: Int
  size_type: String
  category: String
}

input ProductUpdateOneInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductWhereUniqueInput
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  brand: String
  brand_not: String
  brand_in: [String!]
  brand_not_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_gt: String
  brand_gte: String
  brand_contains: String
  brand_not_contains: String
  brand_starts_with: String
  brand_not_starts_with: String
  brand_ends_with: String
  brand_not_ends_with: String
  size: Int
  size_not: Int
  size_in: [Int!]
  size_not_in: [Int!]
  size_lt: Int
  size_lte: Int
  size_gt: Int
  size_gte: Int
  size_type: String
  size_type_not: String
  size_type_in: [String!]
  size_type_not_in: [String!]
  size_type_lt: String
  size_type_lte: String
  size_type_gt: String
  size_type_gte: String
  size_type_contains: String
  size_type_not_contains: String
  size_type_starts_with: String
  size_type_not_starts_with: String
  size_type_ends_with: String
  size_type_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  authPaylod(where: AuthPaylodWhereUniqueInput!): AuthPaylod
  authPaylods(where: AuthPaylodWhereInput, orderBy: AuthPaylodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AuthPaylod]!
  authPaylodsConnection(where: AuthPaylodWhereInput, orderBy: AuthPaylodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AuthPaylodConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  vendor(where: VendorWhereUniqueInput!): Vendor
  vendors(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vendor]!
  vendorsConnection(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VendorConnection!
  node(id: ID!): Node
}

type Subscription {
  authPaylod(where: AuthPaylodSubscriptionWhereInput): AuthPaylodSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  vendor(where: VendorSubscriptionWhereInput): VendorSubscriptionPayload
}

type Vendor {
  id: ID!
  name: String!
  username: String!
  password: String!
  createdAt: DateTime
}

type VendorConnection {
  pageInfo: PageInfo!
  edges: [VendorEdge]!
  aggregate: AggregateVendor!
}

input VendorCreateInput {
  id: ID
  name: String!
  username: String!
  password: String!
}

input VendorCreateOneInput {
  create: VendorCreateInput
  connect: VendorWhereUniqueInput
}

type VendorEdge {
  node: Vendor!
  cursor: String!
}

enum VendorOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
}

type VendorPreviousValues {
  id: ID!
  name: String!
  username: String!
  password: String!
  createdAt: DateTime
}

type VendorSubscriptionPayload {
  mutation: MutationType!
  node: Vendor
  updatedFields: [String!]
  previousValues: VendorPreviousValues
}

input VendorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VendorWhereInput
  AND: [VendorSubscriptionWhereInput!]
  OR: [VendorSubscriptionWhereInput!]
  NOT: [VendorSubscriptionWhereInput!]
}

input VendorUpdateDataInput {
  name: String
  username: String
  password: String
}

input VendorUpdateInput {
  name: String
  username: String
  password: String
}

input VendorUpdateManyMutationInput {
  name: String
  username: String
  password: String
}

input VendorUpdateOneInput {
  create: VendorCreateInput
  update: VendorUpdateDataInput
  upsert: VendorUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneRequiredInput {
  create: VendorCreateInput
  update: VendorUpdateDataInput
  upsert: VendorUpsertNestedInput
  connect: VendorWhereUniqueInput
}

input VendorUpsertNestedInput {
  update: VendorUpdateDataInput!
  create: VendorCreateInput!
}

input VendorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [VendorWhereInput!]
  OR: [VendorWhereInput!]
  NOT: [VendorWhereInput!]
}

input VendorWhereUniqueInput {
  id: ID
  username: String
}
`
      }
    